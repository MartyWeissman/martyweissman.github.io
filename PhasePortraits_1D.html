<!DOCTYPE html>
<html>
<head>
  <style>
    .container {
      max-width: 1000px;
      margin: 20px auto;
      font-family: Arial, sans-serif;
    }
    .title {
      text-align: center;
      font-size: 24px;
      margin: 20px 0;
    }
    .grid-container {
      display: grid;
      grid-template-columns: 3fr 2fr;
      gap: 20px;
      margin-top: 20px;
    }
    .plot-container {
      display: grid;
      grid-template-columns: 20px auto;
      grid-template-rows: auto 25px auto;
      gap: 0;
    }
    .y-axis-label {
      grid-column: 1;
      grid-row: 1;
      writing-mode: vertical-rl;
      transform: rotate(180deg);
      display: flex;
      align-items: center;
      justify-content: center;
      color: #333;
      font-size: 14px;
      padding: 10px 0;
    }
    .phase-plot {
      grid-column: 2;
      grid-row: 1;
      border: 1px solid #ccc;
      background: white;
    }
    .x-axis-row {
      grid-column: 2;
      grid-row: 2;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0 10px;
      font-size: 14px;
      color: #333;
    }
    .x-axis-row .center-label {
      flex: 1;
      text-align: center;
    }
    .portrait-plot {
      grid-column: 2;
      grid-row: 3;
      border: 1px solid #ccc;
      background: white;
    }
    .right-column {
      padding: 20px;
      background: #f5f5f5;
      border-radius: 8px;
    }
    .input-row {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 15px;
    }
    .input-row label {
      min-width: 45px;
    }
    .input-row input {
      padding: 8px;
      font-size: 16px;
      width: 150px;
    }
    .error {
      color: red;
      margin-top: 10px;
      font-size: 14px;
    }
    button {
      padding: 8px 16px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }
    button:hover {
      background-color: #45a049;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1 class="title">One-dimensional dynamical system visualizer</h1>
    <div class="grid-container">
      <div class="plot-container">
        <div class="y-axis-label">X'</div>
        <canvas id="phaseCanvas" class="phase-plot" width="600" height="300"></canvas>
        <div class="x-axis-row">
          <span class="left-label" id="xmin-label"></span>
          <span class="center-label">X</span>
          <span class="right-label" id="xmax-label"></span>
        </div>
        <canvas id="portraitCanvas" class="portrait-plot" width="600" height="120"></canvas>
      </div>
      <div class="right-column">
        <div class="input-row">
          <label>X' = </label>
          <input type="text" id="equation" value="2*X - X^2" placeholder="Enter function and press Enter">
        </div>
        <div class="input-row">
          <label>Xmin = </label>
          <input type="number" id="xmin" value="-5" step="0.5">
        </div>
        <div class="input-row">
          <label>Xmax = </label>
          <input type="number" id="xmax" value="5" step="0.5">
        </div>
        <div class="input-row">
          <label>Ymin = </label>
          <input type="number" id="ymin" value="-1" step="0.5">
        </div>
        <div class="input-row">
          <label>Ymax = </label>
          <input type="number" id="ymax" value="1" step="0.5">
        </div>
        <button id="autozoom">Autozoom</button>
        <button id="reset">Reset window</button>
        <div id="error" class="error"></div>
      </div>
    </div>
  </div>

  <script>
    function parseAndEvaluate(expr, x) {
      expr = expr.replace(/\^/g, '**')
                 .replace(/X/g, `(${x})`)
                 .replace(/\b(?:sin|cos|tan|exp|log)\b/g, 'Math.$&');
      try {
        return Function('return ' + expr)();
      } catch (e) {
        throw new Error(`Error evaluating F(${x}): ${e.message}`);
      }
    }

    function findEquilibriumPoints(expr, xMin, xMax) {
        const points = [];
        const steps = 1000;
        const dx = (xMax - xMin) / steps;

        let lastY = parseAndEvaluate(expr, xMin);

        for (let i = 1; i <= steps; i++) {
            const x = xMin + i * dx;
            const y = parseAndEvaluate(expr, x);

            if (isNaN(y)) continue;

            if (lastY * y <= 0 && !isNaN(lastY)) {
                let left = x - dx;
                let right = x;
                for (let j = 0; j < 10; j++) {
                    const mid = (left + right) / 2;
                    const midY = parseAndEvaluate(expr, mid);
                    if (midY * lastY <= 0) {
                        right = mid;
                    } else {
                        left = mid;
                    }
                }
                const newPoint = (left + right) / 2;

                // Only add if it's not very close to an existing point
                const tolerance = dx/100;
                const isDuplicate = points.some(p => Math.abs(p - newPoint) < tolerance);
                if (!isDuplicate) {
                    points.push(newPoint);
                }
            }
            lastY = y;
        }

        return points;
    }

    function findYRange(expr, xMin, xMax) {
      const steps = 1000;
      const dx = (xMax - xMin) / steps;
      let yMin = Infinity;
      let yMax = -Infinity;

      for (let i = 0; i <= steps; i++) {
        const x = xMin + i * dx;
        const y = parseAndEvaluate(expr, x);
        if (!isNaN(y)) {
          yMin = Math.min(yMin, y);
          yMax = Math.max(yMax, y);
        }
      }

      return [yMin, yMax];
    }

    const phaseCanvas = document.getElementById('phaseCanvas');
    const phaseCtx = phaseCanvas.getContext('2d');
    const portraitCanvas = document.getElementById('portraitCanvas');
    const portraitCtx = portraitCanvas.getContext('2d');
    const equationInput = document.getElementById('equation');

    function transformX(x) {
      return (x - xMin) * phaseCanvas.width / (xMax - xMin);
    }

    function transformY(y, canvas) {
      return canvas.height - (y - yMin) * canvas.height / (yMax - yMin);
    }

    function drawPhaseAxes() {
      phaseCtx.clearRect(0, 0, phaseCanvas.width, phaseCanvas.height);

      // Draw grid lines at equilibrium points
      phaseCtx.beginPath();
      phaseCtx.strokeStyle = '#eee';
      equilibriumPoints.forEach(x => {
        const screenX = transformX(x);
        phaseCtx.moveTo(screenX, 0);
        phaseCtx.lineTo(screenX, phaseCanvas.height);
      });
      phaseCtx.stroke();

      // Draw horizontal axis only
      phaseCtx.beginPath();
      phaseCtx.strokeStyle = '#999';
      phaseCtx.moveTo(0, transformY(0, phaseCanvas));
      phaseCtx.lineTo(phaseCanvas.width, transformY(0, phaseCanvas));
      phaseCtx.stroke();

      // Draw equilibrium point labels (top)
      phaseCtx.font = '12px Arial';
      phaseCtx.fillStyle = '#666';
      phaseCtx.textAlign = 'center';
      equilibriumPoints.forEach(x => {
        phaseCtx.fillText(x.toFixed(2), transformX(x), 15);
      });
    }

    function drawPhaseCurve(expr) {
      phaseCtx.beginPath();
      phaseCtx.strokeStyle = 'blue';

      let isFirst = true;
      let lastY = null;

      for(let px = 0; px < phaseCanvas.width; px++) {
        const x = xMin + (xMax - xMin) * px / phaseCanvas.width;
        const y = parseAndEvaluate(expr, x);

        if (isNaN(y)) continue;

        if (isFirst) {
          phaseCtx.moveTo(px, transformY(y, phaseCanvas));
          isFirst = false;
        } else if (Math.abs(y - lastY) < phaseCanvas.height) {
          phaseCtx.lineTo(px, transformY(y, phaseCanvas));
        } else {
          phaseCtx.moveTo(px, transformY(y, phaseCanvas));
        }
        lastY = y;
      }
      phaseCtx.stroke();
    }

    function drawHorizontalArrow(ctx, tailX, headX, yOffset) {
        const arrowHeadLength = 10;  // Length of arrowhead
        const arrowHeadWidth = 4;    // Max width of arrowhead
        const barbDepth = 2;         // How far the barb curves inward
        const y = portraitCanvas.height/3 + yOffset;

        // Draw main line
        ctx.beginPath();
        ctx.moveTo(tailX, y);
        ctx.lineTo(headX, y);
        ctx.stroke();

        // Draw arrowhead
        ctx.beginPath();
        if (headX > tailX) {  // Right-pointing arrow
            ctx.moveTo(headX, y);
            ctx.lineTo(headX - arrowHeadLength, y - arrowHeadWidth);
            ctx.lineTo(headX - arrowHeadLength + barbDepth, y);  // Barb curve
            ctx.lineTo(headX - arrowHeadLength, y + arrowHeadWidth);
        } else {  // Left-pointing arrow
            ctx.moveTo(headX, y);
            ctx.lineTo(headX + arrowHeadLength, y - arrowHeadWidth);
            ctx.lineTo(headX + arrowHeadLength - barbDepth, y);  // Barb curve
            ctx.lineTo(headX + arrowHeadLength, y + arrowHeadWidth);
        }
        ctx.closePath();
        ctx.fillStyle = 'black';
        ctx.fill();
    }

    function getIntervals() {
        // Create array [Xmin, E1, E2, ..., En, Xmax]
        const points = [xMin, ...equilibriumPoints, xMax].sort((a, b) => a - b);

        // Create intervals
        const intervals = [];
        for (let i = 0; i < points.length - 1; i++) {
            intervals.push({
                start: points[i],
                end: points[i+1],
                length: points[i+1] - points[i]
            });
        }
        return intervals;
    }

    function placeArrowsInInterval(ctx, interval) {
        const totalRange = xMax - xMin;
        const relativeLength = interval.length / totalRange;
        const arrowLength = Math.min(30, interval.length * portraitCanvas.width / totalRange / 3);

        // Determine number of arrows based on interval length
        let numArrows;
        if (relativeLength < 0.2) numArrows = 1;
        else if (relativeLength < 0.5) numArrows = 2;
        else numArrows = 3;

        // Calculate spacing for arrows
        const spacePerArrow = interval.length / (numArrows + 1);
        const direction = parseAndEvaluate(equationInput.value, (interval.start + interval.end) / 2) > 0;

        // Draw arrows
        for (let i = 1; i <= numArrows; i++) {
            const centerX = interval.start + i * spacePerArrow;
            const screenCenterX = transformX(centerX);
            const tailX = screenCenterX - arrowLength/2;
            const headX = screenCenterX + arrowLength/2;

            drawHorizontalArrow(ctx,
                direction ? tailX : headX,
                direction ? headX : tailX,
                20);
        }
    }

    function drawPhasePortrait() {
        portraitCtx.clearRect(0, 0, portraitCanvas.width, portraitCanvas.height);

        // Draw horizontal line
        portraitCtx.beginPath();
        portraitCtx.strokeStyle = 'black';
        portraitCtx.moveTo(0, portraitCanvas.height/3);
        portraitCtx.lineTo(portraitCanvas.width, portraitCanvas.height/3);
        portraitCtx.stroke();

        // Draw equilibrium points
        equilibriumPoints.forEach(x => {
            const screenX = transformX(x);

            // Draw dot
            portraitCtx.beginPath();
            portraitCtx.arc(screenX, portraitCanvas.height/3, 6, 0, 2*Math.PI);
            portraitCtx.strokeStyle = 'black';

            // Check stability
            const eps = 0.001;
            const leftDeriv = parseAndEvaluate(equationInput.value, x - eps);
            const rightDeriv = parseAndEvaluate(equationInput.value, x + eps);
            const isStable = leftDeriv > 0 && rightDeriv < 0;

            portraitCtx.fillStyle = isStable ? '#444' : 'white';
            portraitCtx.fill();
            portraitCtx.stroke();

            // Draw number label above dot
            portraitCtx.fillStyle = 'black';
            portraitCtx.textAlign = 'center';
            portraitCtx.fillText(x.toFixed(2), screenX, portraitCanvas.height/3 - 15);
        });

        // Draw arrows for each interval
        const intervals = getIntervals();
        intervals.forEach(interval => placeArrowsInInterval(portraitCtx, interval));
    }

    function autoZoom() {
      const expr = document.getElementById('equation').value;

      if (equilibriumPoints.length === 0) return;

      if (equilibriumPoints.length === 1) {
        const E = equilibriumPoints[0];
        xMin = E - 1;
        xMax = E + 1;
      } else {
        const Emin = Math.min(...equilibriumPoints);
        const Emax = Math.max(...equilibriumPoints);
        const Erange = Emax - Emin;
        xMin = Emin - (Erange / 5);
        xMax = Emax + (Erange / 5);
      }

      // Update X range inputs
      document.getElementById('xmin').value = xMin;
      document.getElementById('xmax').value = xMax;

      // Find Y range
      const [newYmin, newYmax] = findYRange(expr, xMin, xMax);
      const yPadding = (newYmax - newYmin) * 0.1;
      yMin = newYmin - yPadding;
      yMax = newYmax + yPadding;

      // Update Y range inputs
      document.getElementById('ymin').value = yMin;
      document.getElementById('ymax').value = yMax;

      updateVisualization();
    }

    // In the JavaScript, add:
    function resetWindow() {
        document.getElementById('xmin').value = -5;
        document.getElementById('xmax').value = 5;
        document.getElementById('ymin').value = -1;
        document.getElementById('ymax').value = 1;
        updateVisualization();
    }

    let xMin = -5;
    let xMax = 5;
    let yMin = -1;
    let yMax = 1;
    let equilibriumPoints = [];

    // Update X-axis labels
    function updateAxisLabels() {
      document.getElementById('xmin-label').textContent = xMin.toFixed(1);
      document.getElementById('xmax-label').textContent = xMax.toFixed(1);
    }

    // Mouse interaction and simulation variables
let hoverX = null;
let simulationX = null;
let isSimulating = false;
let lastTimestamp = null;
const ballRadius = 6;

// RK4 implementation for X' = F(X)
function rk4Step(x, dt) {
    const k1 = parseAndEvaluate(equationInput.value, x);
    const k2 = parseAndEvaluate(equationInput.value, x + k1 * dt/2);
    const k3 = parseAndEvaluate(equationInput.value, x + k2 * dt/2);
    const k4 = parseAndEvaluate(equationInput.value, x + k3 * dt);
    return x + (dt/6) * (k1 + 2*k2 + 2*k3 + k4);
}

function drawBall(ctx, x, opacity) {
    const screenX = transformX(x);
    const y = portraitCanvas.height/3;

    ctx.beginPath();
    ctx.arc(screenX, y, ballRadius, 0, 2*Math.PI);
    ctx.fillStyle = `rgba(0, 255, 0, ${opacity})`;
    ctx.fill();
    ctx.strokeStyle = 'black';
    ctx.stroke();
}
let lastScreenX = null;
let lastCheckTime = null;

function animate(timestamp) {
    if (!lastTimestamp) {
        lastTimestamp = timestamp;
        lastCheckTime = timestamp;
        lastScreenX = transformX(simulationX);
    }
    const dt = (timestamp - lastTimestamp) / 1000;
    lastTimestamp = timestamp;

    if (isSimulating && simulationX !== null) {
        // Update position
        simulationX = rk4Step(simulationX, dt);

        // Check for minimal movement every 0.1 seconds
        if (timestamp - lastCheckTime > 100) {  // 100ms = 0.1s
            const newScreenX = transformX(simulationX);
            const screenMovement = Math.abs(newScreenX - lastScreenX);
            if (screenMovement < 0.5) {
                isSimulating = false;
                return;
            }
            lastScreenX = newScreenX;
            lastCheckTime = timestamp;
        }

        // Check for out of bounds
        const margin = 0.05 * (xMax - xMin);
        if (simulationX < xMin - margin || simulationX > xMax + margin) {
            isSimulating = false;
            return;
        }

        // Redraw phase portrait with current ball position
        drawPhasePortrait();
        drawBall(portraitCtx, simulationX, 1.0);

        // Continue animation
        requestAnimationFrame(animate);
    }
}

// Mouse event listeners with proper offset calculation
portraitCanvas.addEventListener('mousemove', (e) => {
    const rect = portraitCanvas.getBoundingClientRect();
    const scaleX = portraitCanvas.width / rect.width;  // Account for any scaling
    const x = xMin + (xMax - xMin) * (e.clientX - rect.left) * scaleX / portraitCanvas.width;

    if (!isSimulating) {
        hoverX = x;
        drawPhasePortrait();
        drawBall(portraitCtx, x, 0.5);
    }
});

portraitCanvas.addEventListener('mouseleave', () => {
    if (!isSimulating) {
        hoverX = null;
        drawPhasePortrait();
    }
});

// Reset these when starting new simulation
portraitCanvas.addEventListener('click', (e) => {
    const rect = portraitCanvas.getBoundingClientRect();
    const scaleX = portraitCanvas.width / rect.width;
    const x = xMin + (xMax - xMin) * (e.clientX - rect.left) * scaleX / portraitCanvas.width;

    simulationX = x;
    isSimulating = true;
    lastTimestamp = null;
    lastScreenX = null;    // Reset screen position tracker
    lastCheckTime = null;  // Reset time tracker
    requestAnimationFrame(animate);
});

function updateVisualization() {
    document.getElementById('error').textContent = '';
    const expr = equationInput.value;
    xMin = parseFloat(document.getElementById('xmin').value);
    xMax = parseFloat(document.getElementById('xmax').value);
    yMin = parseFloat(document.getElementById('ymin').value);
    yMax = parseFloat(document.getElementById('ymax').value);

    try {
        // Stop any ongoing simulation when visualization updates
        isSimulating = false;
        simulationX = null;
        hoverX = null;

        equilibriumPoints = findEquilibriumPoints(expr, xMin, xMax);
        drawPhaseAxes();
        drawPhaseCurve(expr);
        drawPhasePortrait();
    } catch (e) {
        document.getElementById('error').textContent = e.message;
    }
}

// Event listeners
document.getElementById('equation').addEventListener('keypress', function(e) {
    if (e.key === 'Enter') {
        updateVisualization();
    }
});

document.getElementById('xmin').addEventListener('change', updateVisualization);
document.getElementById('xmax').addEventListener('change', updateVisualization);
document.getElementById('ymin').addEventListener('change', updateVisualization);
document.getElementById('ymax').addEventListener('change', updateVisualization);
document.getElementById('autozoom').addEventListener('click', autoZoom);
document.getElementById('reset').addEventListener('click', resetWindow);

updateVisualization(); // Initial draw
</script>
</body>
</html>
